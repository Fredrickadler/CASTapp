import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Updater, CommandHandler, CallbackQueryHandler, CallbackContext, MessageHandler, Filters
import datetime
import json
import os
from uuid import uuid4

# Enable logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO
)
logger = logging.getLogger(__name__)

# Bot configuration
TOKEN = "YOUR_TELEGRAM_BOT_TOKEN"
ADMIN_TASK_CODE = "Fredrick"  # Hidden admin code for adding tasks

# Data storage
USER_DATA_FILE = "user_data.json"
TASKS_FILE = "tasks.json"

# Load user data from file
def load_user_data():
    if os.path.exists(USER_DATA_FILE):
        with open(USER_DATA_FILE, "r") as f:
            return json.load(f)
    return {}

# Save user data to file
def save_user_data(data):
    with open(USER_DATA_FILE, "w") as f:
        json.dump(data, f)

# Load tasks from file
def load_tasks():
    if os.path.exists(TASKS_FILE):
        with open(TASKS_FILE, "r") as f:
            return json.load(f)
    return {
        "tasks": [
            {"id": "1", "type": "follow", "title": "Follow our Twitter", "points": 50, "completed_by": []},
            {"id": "2", "type": "like", "title": "Like our tweet", "points": 30, "completed_by": []},
            {"id": "3", "type": "retweet", "title": "Retweet our tweet", "points": 40, "completed_by": []}
        ]
    }

# Save tasks to file
def save_tasks(tasks):
    with open(TASKS_FILE, "w") as f:
        json.dump(tasks, f)

# Initialize data
user_data = load_user_data()
tasks_data = load_tasks()

# Main menu keyboard
def main_menu_keyboard():
    keyboard = [
        [InlineKeyboardButton("üè† Home", callback_data='home')],
        [InlineKeyboardButton("üìã Tasks", callback_data='tasks')],
        [InlineKeyboardButton("üë§ Profile", callback_data='profile')]
    ]
    return InlineKeyboardMarkup(keyboard)

# Home screen
def home_screen(update: Update, context: CallbackContext):
    query = update.callback_query
    user_id = str(query.from_user.id)
    
    if user_id not in user_data:
        user_data[user_id] = {
            "points": 0,
            "last_claim": None,
            "username": query.from_user.username,
            "first_name": query.from_user.first_name,
            "last_name": query.from_user.last_name,
            "completed_tasks": []
        }
        save_user_data(user_data)
    
    user = user_data[user_id]
    can_claim = True
    claim_text = "üü¢ Claim Now (11 points)"
    
    if user["last_claim"]:
        last_claim = datetime.datetime.fromisoformat(user["last_claim"])
        next_claim = last_claim + datetime.timedelta(hours=6)
        if datetime.datetime.now() < next_claim:
            can_claim = False
            time_left = next_claim - datetime.datetime.now()
            hours = time_left.seconds // 3600
            minutes = (time_left.seconds % 3600) // 60
            claim_text = f"üî¥ Next claim in {hours}h {minutes}m"
    
    keyboard = [
        [InlineKeyboardButton(claim_text, callback_data='claim' if can_claim else 'cant_claim')],
        [InlineKeyboardButton("üìã Tasks", callback_data='tasks')],
        [InlineKeyboardButton("üë§ Profile", callback_data='profile')]
    ]
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    query.edit_message_text(
        text=f"üè† *Home*\n\nYour points: *{user['points']}*",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

# Claim points
def claim_points(update: Update, context: CallbackContext):
    query = update.callback_query
    user_id = str(query.from_user.id)
    
    if user_id not in user_data:
        user_data[user_id] = {
            "points": 0,
            "last_claim": None,
            "username": query.from_user.username,
            "first_name": query.from_user.first_name,
            "last_name": query.from_user.last_name,
            "completed_tasks": []
        }
    
    user = user_data[user_id]
    
    if user["last_claim"]:
        last_claim = datetime.datetime.fromisoformat(user["last_claim"])
        next_claim = last_claim + datetime.timedelta(hours=6)
        if datetime.datetime.now() < next_claim:
            query.answer("You can claim again in " + str(next_claim - datetime.datetime.now()).split(".")[0], show_alert=True)
            return
    
    user["points"] += 11
    user["last_claim"] = datetime.datetime.now().isoformat()
    save_user_data(user_data)
    
    query.answer("You claimed 11 points!", show_alert=True)
    home_screen(update, context)

# Tasks screen
def tasks_screen(update: Update, context: CallbackContext):
    query = update.callback_query
    user_id = str(query.from_user.id)
    
    if user_id not in user_data:
        user_data[user_id] = {
            "points": 0,
            "last_claim": None,
            "username": query.from_user.username,
            "first_name": query.from_user.first_name,
            "last_name": query.from_user.last_name,
            "completed_tasks": []
        }
        save_user_data(user_data)
    
    user = user_data[user_id]
    tasks = tasks_data["tasks"]
    
    task_buttons = []
    for task in tasks:
        if task["id"] in user["completed_tasks"]:
            task_buttons.append([InlineKeyboardButton(f"‚úÖ {task['title']} (+{task['points']})", callback_data=f'task_completed_{task["id"]}')])
        else:
            task_buttons.append([InlineKeyboardButton(f"{task['title']} (+{task['points']})", callback_data=f'task_{task["id"]}')])
    
    keyboard = task_buttons + [
        [InlineKeyboardButton("üè† Home", callback_data='home')],
        [InlineKeyboardButton("üë§ Profile", callback_data='profile')]
    ]
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    query.edit_message_text(
        text="üìã *Tasks*\n\nComplete tasks to earn more points:",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

# Complete task
def complete_task(update: Update, context: CallbackContext):
    query = update.callback_query
    user_id = str(query.from_user.id)
    task_id = query.data.split('_')[1]
    
    if user_id not in user_data:
        user_data[user_id] = {
            "points": 0,
            "last_claim": None,
            "username": query.from_user.username,
            "first_name": query.from_user.first_name,
            "last_name": query.from_user.last_name,
            "completed_tasks": []
        }
    
    user = user_data[user_id]
    
    if task_id in user["completed_tasks"]:
        query.answer("You've already completed this task!", show_alert=True)
        return
    
    task = next((t for t in tasks_data["tasks"] if t["id"] == task_id), None)
    if not task:
        query.answer("Task not found!", show_alert=True)
        return
    
    user["points"] += task["points"]
    user["completed_tasks"].append(task_id)
    task["completed_by"].append(user_id)
    
    save_user_data(user_data)
    save_tasks(tasks_data)
    
    query.answer(f"You earned {task['points']} points!", show_alert=True)
    tasks_screen(update, context)

# Profile screen
def profile_screen(update: Update, context: CallbackContext):
    query = update.callback_query
    user_id = str(query.from_user.id)
    
    if user_id not in user_data:
        user_data[user_id] = {
            "points": 0,
            "last_claim": None,
            "username": query.from_user.username,
            "first_name": query.from_user.first_name,
            "last_name": query.from_user.last_name,
            "completed_tasks": []
        }
        save_user_data(user_data)
    
    user = user_data[user_id]
    
    # Calculate rank (simple implementation)
    all_users = sorted(user_data.items(), key=lambda x: x[1]["points"], reverse=True)
    rank = next((i+1 for i, (uid, _) in enumerate(all_users) if uid == user_id, len(all_users)+1)
    
    keyboard = [
        [InlineKeyboardButton("üîó Share Profile", switch_inline_query=f"Check out my airdrop profile! I have {user['points']} points!")],
        [InlineKeyboardButton("üè† Home", callback_data='home')],
        [InlineKeyboardButton("üìã Tasks", callback_data='tasks')]
    ]
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    profile_pic = "https://via.placeholder.com/150/7289da/FFFFFF?text=Profile"  # Default profile image
    
    query.edit_message_text(
        text=f"üë§ *Profile*\n\n"
             f"üÜî: @{user['username'] or 'N/A'}\n"
             f"üë§: {user['first_name']} {user.get('last_name', '')}\n"
             f"üèÜ Rank: #{rank}\n"
             f"‚≠ê Points: {user['points']}\n"
             f"‚úÖ Completed tasks: {len(user['completed_tasks'])}",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

# Add task (admin only)
def add_task(update: Update, context: CallbackContext):
    if not context.args:
        update.message.reply_text("Usage: /addtask <code> <type> <title> <points>")
        return
    
    if len(context.args) < 4:
        update.message.reply_text("Usage: /addtask <code> <type> <title> <points>")
        return
    
    code = context.args[0]
    if code != ADMIN_TASK_CODE:
        update.message.reply_text("Invalid code!")
        return
    
    task_type = context.args[1]
    title = " ".join(context.args[2:-1])
    points = context.args[-1]
    
    if not points.isdigit():
        update.message.reply_text("Points must be a number!")
        return
    
    new_task = {
        "id": str(uuid4()),
        "type": task_type,
        "title": title,
        "points": int(points),
        "completed_by": []
    }
    
    tasks_data["tasks"].append(new_task)
    save_tasks(tasks_data)
    
    update.message.reply_text(f"New task added: {title} (+{points} points)")

# Start command
def start(update: Update, context: CallbackContext):
    update.message.reply_text(
        "üöÄ Welcome to the Airdrop Bot!\n\n"
        "Earn points by completing tasks and claiming rewards. "
        "Use the menu below to navigate:",
        reply_markup=main_menu_keyboard()
    )

# Button handler
def button(update: Update, context: CallbackContext):
    query = update.callback_query
    query.answer()
    
    if query.data == 'home':
        home_screen(update, context)
    elif query.data == 'tasks':
        tasks_screen(update, context)
    elif query.data == 'profile':
        profile_screen(update, context)
    elif query.data == 'claim':
        claim_points(update, context)
    elif query.data.startswith('task_') and not query.data.startswith('task_completed_'):
        complete_task(update, context)
    elif query.data == 'cant_claim':
        query.answer("You can't claim yet!", show_alert=True)

# Error handler
def error(update: Update, context: CallbackContext):
    logger.warning('Update "%s" caused error "%s"', update, context.error)

def main():
    # Create the Updater and pass it your bot's token.
    updater = Updater(TOKEN)

    # Get the dispatcher to register handlers
    dp = updater.dispatcher

    # Add command handlers
    dp.add_handler(CommandHandler("start", start))
    dp.add_handler(CommandHandler("addtask", add_task))
    
    # Add callback query handler
    dp.add_handler(CallbackQueryHandler(button))

    # Add error handler
    dp.add_error_handler(error)

    # Start the Bot
    updater.start_polling()

    # Run the bot until you press Ctrl-C or the process receives SIGINT,
    # SIGTERM or SIGABRT. This should be used most of the time, since
    # start_polling() is non-blocking and will stop the bot gracefully.
    updater.idle()

if __name__ == '__main__':
    main()